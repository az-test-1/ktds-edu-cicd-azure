

# 1. Git Branch 전략



## 1) Git Flow

Git Flow는 크게 5개의 브랜치를 만들어 상호 운영되는 전략이다. 각 브랜치는 고유의 기능이 있다. 일부 브랜치는 병합을 통하여 지속적으로 유지되는 브랜치도 있다.



### (1) 브랜치 종류

 - Master(main)
   - 현재 릴리즈된 코드의 저장소임. 언제든지 Production에 출시가 가능한 브랜치
   - Master(Main) Branch에서 tag를 만들고 Production에 배포
- Develop
  - Master 로 부터 브랜치를 분기하여 추가 개발사항을 반영
  - 신규 개발된 내역이 처음 합쳐지는 브랜치
- Feature
  - 새로운 단위 기능을 개발하기 위해 Develop로 부터 브랜치를 분기, 
  - feature라는 단일 브랜치가 있는건 아니고 변경건이 존재할 때마나 생성
  - 기능 개발 단위로 Feature 브랜치가 생성됨
- Release
  - Develop 브랜치에서 생성됨
  - 개발이 완료되어 출시를 위해 준비하는 브랜치
  - 릴리즈 이후 Master/Develop 으로 Merge 됨
- Hotfix
  - Production에 배포 된 버전에서 발생한 버그를 수정하는 브랜치
  - 핫픽스 된 부분은 개발 과정에서도 반영이 되야 하므로 Develop 브랜치에도 같이 Merge함



### (2) Flow

![img](./assets/img-20241001141304728.png)





## 2) Github Flow

프로젝트 규모나 수준을 고려하여 Git Flow 사용이 복잡할 경우 좀더 가볍게 적용할 수 브랜치 전략이다. Hotfir/Feature 브랜치를 구분하지 않으며 수시로 배포가 일어나는 프로젝트에 유용하다.



### (1) 브랜치 종류

Github Flow 브랜치 전략은 총 2개의 브랜치로 나누어진다.

* Master(Main)
  * Gif Flow 와 유사함, 현래 릴리즈된 코드의 저장소
  * 언제든 배포가능한 상태의 코드를 저장함
* Feature
  * 새로운 기능 개발을 위한 브랜치이며 Master 브랜치에서 분기
  * 개발이 완료되면 Master 브랜체로 Merge 함





### (2) Flow

![img](./assets/img.png)



### (3) 특징

- Github Flow 에서는 Master 브랜치 하나로 개발/운영 환경을 모두 관리한다.
- 변경사항이 Master 로 병합되기전에 코드리뷰와 테스트를 통과해야 한다.
- Github Flow 는 규모가 작은 팀이나 지속적으로 빠르게 배포해야 하는 서비스에 적합하다.





## 3) 브랜치 전략별 비교

| 특징        | Git Flow                                     | GitHub Flow                         |
| ----------- | -------------------------------------------- | ----------------------------------- |
| 주요 브랜치 | master, develop, feature, release, hotfix    | master, feature                     |
| 개발 흐름   | 선형적인 개발 흐름, 각 기능 별 브랜치 생성   | main 브랜치 중심, Pull Request 기반 |
| 장점        | 안정적인 릴리즈 관리, 복잡한 프로젝트에 적합 | 협업 효율성, 품질 보장, 빠른 배포   |
| 단점        | 복잡한 브랜치 관리, 느린 배포                | 빈번한 병합으로 인한 충돌 가능성    |





# 2. Application 버전 관리

Application 빌드시 필요한 Versioning은 아래와 같이 2가지 방식이 주로 많이 사용된다.



## 1) Semantic Versioning

### (1) 구조

Semantic Versioning은 **MAJOR.MINOR.PATCH** 형식으로 버전을 정의하는 방식이다.

- **MAJOR**: API에 **호환되지 않는 변경**이 있을 때 증가.
- **MINOR**: 새로운 기능이 추가되지만 **호환성은 유지**될 때 증가.
- **PATCH**: **버그 수정** 등 **기능은 변화하지 않지만 개선**이 이루어질 때 증가.



### (2) 예시

- 1.0.0: 초기 릴리즈
- 1.1.0: 새로운 기능 추가
- 2.0.0: 호환되지 않는 변경 (예: API 변경)
- 1.0.1: 버그 수정



## 2) Date-based versioning

- **릴리스된 날짜 혹은 빌드타임**를 기준으로 버전을 지정하는 방식이다. 
- 주로 릴리스 주기가 **정기적**이거나 **빈번한 릴리스**가 요구되는 프로젝트에서 사용된다. 
- 이 방식은 각 버전이 **릴리스된 시점**을 명확히 나타내므로, **배포 주기**가 짧거나 **신속한 업데이트**가 중요한 경우에 적합하다.

### (1) 예시

* 202x05151255
* 202x09301310



# 3. Container Image Tag 관리 전략

Image tagging 전략도 Application 버전과 동일하게 Semantic Versioning과 Date-based versioning 방식을 많이 사용한다.  하지만 브랜치 전략이 Github flow 같은 1개의 이미지로 여러 환경에 배포할땐, 운영환경에 배포될 별도의 이미지 관리가 필요하다.



## 1) Release Branch를 이용한 관리

- main branch 에서 release branch로 병합될때 CI가 수행되어 docker tagging 하는 전략이다.
- 예를 들어 "application-name:release241010" 과 같은 방식으로, relase 에 대한 정보를 태그에 포함해 운영환경에 배포된 이미지를 구분하고 관리한다.
- 장점
  - 릴리즈 단위로 이미지를 관리하기 용이함, 운영 환경별 이미지를 명확하게 구분

- 단점
  - 브랜치 관리가 추가적으로 필요


## 2) Git tag를 이용한 관리

- Git tag 가 Push 되면 이때, CI 를 수행해 Docker 이미지의 태깅을 하는 방법이다.
- Release 브랜치와 차이점은, release 브랜치에 머지하지 않고 Git tag만으로 관리하는 점이다.
- 장점
  - 간단한 관리, Git을 통해 릴리즈 시점을 명확히 알 수 있음
- 단점
  - 이미지 태그가 많아질 경우 관리가 어려울 수 있음