

# Github Action



[[_TOC_]]



# 1. 개요

GitHub Actions를 사용하여 컨테이너 환경에서 Continuous Integration (CI) 작업을 수행하는 workflow를 살펴본다.



# 2. 1st workFlow

## 1) workflow

프로젝트 루트 디렉토리에 `.github/workflows` 디렉토리를 만들고, 그 안에 `sample-ci.yml` 파일을 생성한다.

```yaml
name: sample-ci


on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Run tests
        run: |
          docker run --rm myapp:${{ github.sha }} /bin/sh -c "echo Running tests && exit 0"

      - name: Upload Docker image to Docker Hub
        if: github.ref == 'refs/heads/main'
        uses: docker/login-action@v1
        with:
          username: ${{ variables.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main'
        run: |
          docker tag myapp:${{ github.sha }} myapp:latest
          docker push myapp:${{ github.sha }}
          docker push myapp:latest
```



## 2) 설명

1. **이벤트 트리거**:

   - `on: push`: main 브랜치에 푸시될 때 트리거된다.
   - `on: pull_request`: main 브랜치에 대한 pull request가 열리거나 업데이트될 때 트리거된다.

   

2. **작업 설정 (jobs)**:

   - `build`: 이 작업은 `ubuntu-latest` 환경에서 실행된다.

   

3. **단계 (steps)**:

   - **체크아웃 리포지토리**: `actions/checkout@v2` 액션을 사용하여 리포지토리를 체크아웃한다.
   - **Docker Buildx 설정**: `docker/setup-buildx-action@v1` 액션을 사용하여 Docker Buildx를 설정한다.
   - **Docker 레이어 캐시**: `actions/cache@v2` 액션을 사용하여 Docker 레이어를 캐시한다. 이는 빌드 속도를 향상시키는 데 도움이 된다.
   - **Docker 이미지 빌드**: `docker build` 명령어를 사용하여 Docker 이미지를 빌드한다.
   - **테스트 실행**: Docker 컨테이너에서 테스트를 실행한다. 여기서는 간단히 `echo` 명령어로 테스트를 대체한다.
   - **Docker Hub 로그인**: `docker/login-action@v1` 액션을 사용하여 Docker Hub에 로그인한다. Docker Hub 자격 증명은 GitHub Secrets에 저장되어 있어야 한다 (`DOCKER_USERNAME` 및 `DOCKER_PASSWORD`).
   - **Docker 이미지 푸시**: `docker push` 명령어를 사용하여 빌드된 이미지를 Docker Hub에 푸시한다.

   



# 3. 2nd workflow

## 1) workflow

```yaml
name: CI Pipeline

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Login to Azure CLI
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Log in to Azure Container Registry
        run: |
          echo ${{ secrets.AZURE_CLIENT_SECRET }} | docker login ${{ secrets.ACR_NAME }}.azurecr.io -u ${{ secrets.AZURE_CLIENT_ID }} --password-stdin
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/myapp:${{ github.sha }} .
      - name: Push Docker image to ACR
        run: |
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/myapp:${{ github.sha }}
      - name: Logout from Azure Container Registry
        run: |
          docker logout ${{ secrets.ACR_NAME }}.azurecr.io
          
```



## 2) 설명





# 4. 3rd workflow

## 1) workflow

```yml

name: Docker

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      env:
        description: 'Select a env'
        required: true
        type: choice
        options:
          - DEV
          - PRD
      #TagVersion:
      #  description: 'Tag version for Docker image'
      #  required: true
      #  default: 'v1.0.0'
      #  type: string

jobs:
  build:

    runs-on: ubuntu-latest
    # runs-on: arc-runner-set  # AKS
    # runs-on: self-hosted     # VM

    env:
      IMAGE_NAME: ${{ vars.ACR_NAME }}.azurecr.io/${{ vars.EDUUSERID }}/samplejava
      KUSTOMIZATION_FILE: gitops/kustomization.yaml

    permissions:
      contents: write
      # packages: write
      # id-token: write

    steps:
      - name: Set IMAGE_NAME based on environment
        id: set_image_name
        run: |
          if [[ "${{ github.event.inputs.ENV }}" == "DEV" ]]; then
            TIMESTAMP=$(TZ="Asia/Seoul" date +"%Y%m%d%H%M%S")
            echo "IMAGE_TAG=v$TIMESTAMP" >> $GITHUB_ENV
            echo "KUSTOMIZATION_FILE=manifests/overlays/dev/kustomization.yaml" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=v2.${{ github.run_number }}" >> $GITHUB_ENV
            echo "KUSTOMIZATION_FILE=manifests/overlays/prd/kustomization.yaml" >> $GITHUB_ENV
          fi
          
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@f95db51fddba0c2d1ec667646a06c2ce06100226 # v3.0.0

      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0
        with:
          registry: ${{ vars.ACR_NAME }}.azurecr.io
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Extract metadata (tags, labels) for Docker
      # https://github.com/docker/metadata-action
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@96383f45573cb7f253c731d3b3ab81c87ef81934 # v5.0.0
        with:
          images: ${{ vars.ACR_NAME }}.azurecr.io/${{ vars.EDUUSERID }}/samplejava

      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@0565240e2d4ab88bba5387d719585280857ece09 # v5.0.0
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            ${{ env.IMAGE_NAME }}:latest
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:cache
          cache-to:   type=registry,ref=${{ env.IMAGE_NAME }}:cache,mode=max
          

      - name: Update kustomization.yaml with newTag
        run: |
          sed -i "s/newTag: .*/newTag: ${{ env.IMAGE_TAG }}/" $KUSTOMIZATION_FILE

      - name: Commit and push updated kustomization.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add $KUSTOMIZATION_FILE
          git commit -m "Update image tag to ${{ env.IMAGE_TAG }} in kustomization.yaml"
          git push https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git HEAD:${{ github.ref_name }}
          
```



## 2) 설명







## 3)  Trouble Shooting

### (1) GITHUB_TOKEN 사용시 permission 오류

Action pipeline 수행시 Image Tag 를 수정하는 등 Repo를 직접 수정해야 하는 상황이 있을 수 있다.  이런 수정이 필요하다면 repository에 Read/Write 권한을 부여해야 한다.

그렇지 않으면 403에러가 발생한다.  해결방안은 아래와 같다.



#### 1. **Repository Permission 설정 확인**

먼저, `GITHUB_TOKEN`이 올바른 권한을 가지고 있는지 확인해야 한다. 리포지토리 설정에서 워크플로우가 푸시할 수 있는 권한을 가지고 있는지 확인해야 한다.

1. **리포지토리 설정에서 권한 확인:**
   - 리포지토리로 이동한 다음, "Settings" > "Actions" > "General"로 이동
   - "Workflow permissions" 섹션
   - "Read and write permissions" 옵션이 선택되어 있는지 확인
   - "Allow GitHub Actions to create and approve pull requests" 옵션도 필요에 따라 체크

이 설정을 통해 `GITHUB_TOKEN`이 리포지토리에 푸시할 수 있는 권한을 부여



#### 2. **GitHub Actions YAML 파일에서 GITHUB_TOKEN 설정**

`GITHUB_TOKEN`이 이미 설정되어 있지만, 여전히 문제가 발생하는 경우에는 `git push` 명령어에서 사용하는 토큰 형식을 다음과 같이 수정

```yaml
- name: Commit and push updated kustomization.yaml
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  run: |
    git config --local user.email "github-actions[bot]@users.noreply.github.com"
    git config --local user.name "github-actions[bot]"
    git add $KUSTOMIZATION_FILE
    git commit -m "Update image tag to ${{ github.event.inputs.TagVersion }} in kustomization.yaml"
    git push https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git HEAD:${{ github.ref_name }}
```



