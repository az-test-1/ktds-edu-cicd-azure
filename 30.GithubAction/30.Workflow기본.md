

# Github Action



[[_TOC_]]



# 1. 개요

GitHub Actions를 사용하여 컨테이너 환경에서 Continuous Integration (CI) 작업을 수행하는 워크플로우 를 살펴본다.





# 2. Github CLI 설정



```sh
$ sudo apt install gh

$ gh --version
gh version 2.4.0+dfsg1 (2022-03-23 Ubuntu 2.4.0+dfsg1-2)
https://github.com/cli/cli/releases/latest



```





# 2. ACR 인증을 위한 사전작업



## 1) acr 목록 확인



### (1) 구독 확인

```sh
# 구독 목록 확인
$ az account list --output table

Name         CloudName    SubscriptionId                        TenantId                              State    IsDefault
-----------  -----------  ------------------------------------  ------------------------------------  -------  -----------
ce-pg-study  AzureCloud   0cbb9123-6397-4a37-97d1-8efa0a25043b  a3870566-f011-4691-aa51-5b988c51c03a  Enabled  False
llm-poc      AzureCloud   bbe8692f-000e-471b-ba79-c5eec94ca3d0  a3870566-f011-4691-aa51-5b988c51c03a  Enabled  False
ce-pg        AzureCloud   df568535-0931-439d-a9ae-ca3601367d74  a3870566-f011-4691-aa51-5b988c51c03a  Enabled  False
playground   AzureCloud   3635a8be-5bb2-49ea-a43a-82c892f125e1  a3870566-f011-4691-aa51-5b988c51c03a  Enabled  False
axcoe        AzureCloud   1d6c45e0-bd9f-4771-bb67-36616452f239  a3870566-f011-4691-aa51-5b988c51c03a  Enabled  True


# 구독 변경
az account set --subscription axcoe



# 현재 구독 확인
$ az account show --output table

EnvironmentName    HomeTenantId                          IsDefault    Name         State    TenantDefaultDomain                       TenantDisplayName    TenantId
-----------------  ------------------------------------  -----------  -----------  -------  ----------------------------------------  -------------------  ------------------------------------
AzureCloud         a3870566-f011-4691-aa51-5b988c51c03a  True         ce-pg-study  Enabled  ktdsplaygroundoutlook100.onmicrosoft.com  기본 디렉터리              a3870566-f011-4691-aa51-5b988c51c03a

EnvironmentName    HomeTenantId                          IsDefault    Name    State    TenantDefaultDomain                       TenantDisplayName    TenantId
-----------------  ------------------------------------  -----------  ------  -------  ----------------------------------------  -------------------  ------------------------------------
AzureCloud         a3870566-f011-4691-aa51-5b988c51c03a  True         axcoe   Enabled  ktdsplaygroundoutlook100.onmicrosoft.com  기본 디렉터리              a3870566-f011-4691-aa51-5b988c51c03a



```



### (2) acr 목록 확인

```sh
$ az acr list -o table

NAME         RESOURCE GROUP    LOCATION      SKU    LOGIN SERVER            CREATION DATE         ADMIN ENABLED
-----------  ----------------  ------------  -----  ----------------------  --------------------  ---------------
cepgbaseacr  cepg-aa-std-rg    koreacentral  Basic  cepgbaseacr.azurecr.io  2024-07-19T02:04:42Z  True
cepgstapacr  cepg-aa-std-rg    koreacentral  Basic  cepgstapacr.azurecr.io  2024-07-19T02:05:08Z  False

NAME            RESOURCE GROUP    LOCATION      SKU      LOGIN SERVER               CREATION DATE         ADMIN ENABLED
--------------  ----------------  ------------  -------  -------------------------  --------------------  ---------------
tiuaxcoetmpacr  tiu-axcoe-rg      koreacentral  Premium  tiuaxcoetmpacr.azurecr.io  2024-08-08T05:10:27Z  True


NAME          RESOURCE GROUP    LOCATION      SKU      LOGIN SERVER             CREATION DATE         ADMIN ENABLED
------------  ----------------  ------------  -------  -----------------------  --------------------  ---------------
tiurefappcr   tiu-ref-com-rg    koreacentral  Premium  tiurefappcr.azurecr.io   2024-09-09T03:56:30Z  True
tiurefbasecr  tiu-ref-com-rg    koreacentral  Premium  tiurefbasecr.azurecr.io  2024-09-09T03:56:30Z  True


```





## 2) 서비스 주체

### (1) 서비스 주체 생성

적당한 이름으로 서비스 주체를 생성한다.

**서비스 주체 생성**:

- 아래 명령어를 실행하여 서비스 주체를 생성한다.
- `SERVICE_PRINCIPAL_NAME` 변수를 원하는 이름으로 설정한다.

```sh
# 변수 설정
ACR_NAME=tiurefappcr
RESOURCE_GROUP=tiu-ref-com-rg

# acr id 확인
$ az acr show --name $ACR_NAME --resource-group $RESOURCE_GROUP --query id --output tsv
/subscriptions/0cbb9123-6397-4a37-97d1-8efa0a25043b/resourceGroups/cepg-aa-std-rg/providers/Microsoft.ContainerRegistry/registries/cepgstapacr


# acr id 셋팅
$ ACR_ID=$(az acr show --name $ACR_NAME --resource-group $RESOURCE_GROUP --query id --output tsv)
  echo $ACR_ID



SERVICE_PRINCIPAL_NAME=tiuaxcoerefacr-sp     # <YourServicePrincipalName>


# SP생성
$ az ad sp create-for-rbac \
    --name http://$SERVICE_PRINCIPAL_NAME \
    --role contributor \
    --scopes $ACR_ID \
    --sdk-auth

# 생성된 서비스 주체 정보
{
  "appId": "136ad9d9-2b0b-4498-8d65-275ff3cd7f1b",
  "displayName": "http://myServicePrincipal",
  "password": "r9X8Q~7t7igypZaPz2e5oCt~lDCJTF37j9c_Cc8t",
  "tenant": "a3870566-f011-4691-aa51-5b988c51c03a"
}

The output includes credentials that you must protect. Be sure that you do not include these credentials in your code or check the credentials into your source control. For more information, see https://aka.ms/azadsp-cli
{
  "appId": "136ad9d9-2b0b-4498-8d65-275ff3cd7f1b",
  "displayName": "http://myServicePrincipal",
  "password": "uXF8Q~axPC~NhIYNn~jThdAssiqGoElTnMo3Paku",
  "tenant": "a3870566-f011-4691-aa51-5b988c51c03a"
}


The output includes credentials that you must protect. Be sure that you do not include these credentials in your code or check the credentials into your source control. For more information, see https://aka.ms/azadsp-cli
{
  "clientId": "136ad9d9-2b0b-4498-8d65-275ff3cd7f1b",
  "clientSecret": "xXT8Q~BTzajOohOJPhAV8_moY6qEzsxUhJdqXdza",
  "subscriptionId": "0cbb9123-6397-4a37-97d1-8efa0a25043b",
  "tenantId": "a3870566-f011-4691-aa51-5b988c51c03a",
  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
  "resourceManagerEndpointUrl": "https://management.azure.com/",
  "activeDirectoryGraphResourceId": "https://graph.windows.net/",
  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",
  "galleryEndpointUrl": "https://gallery.azure.com/",
  "managementEndpointUrl": "https://management.core.windows.net/"
}



{
  "clientId": "6f71cdcd-7f75-4522-98d5-95f0ebc5cce6",
  "clientSecret": "3ts8Q~Cp1oDvCWbt1L0Rs~L_o971wjMatmXpvaXw",
  "subscriptionId": "1d6c45e0-bd9f-4771-bb67-36616452f239",
  "tenantId": "a3870566-f011-4691-aa51-5b988c51c03a",
  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
  "resourceManagerEndpointUrl": "https://management.azure.com/",
  "activeDirectoryGraphResourceId": "https://graph.windows.net/",
  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",
  "galleryEndpointUrl": "https://gallery.azure.com/",
  "managementEndpointUrl": "https://management.core.windows.net/"
}


{
  "clientId": "2fa43ddc-14f1-48c5-8582-a6b9bcbab39d",
  "clientSecret": "lQo8Q~0wSX715_l5URAdu~PSL63sp31iJ2HJncR0",
  "subscriptionId": "1d6c45e0-bd9f-4771-bb67-36616452f239",
  "tenantId": "a3870566-f011-4691-aa51-5b988c51c03a",
  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
  "resourceManagerEndpointUrl": "https://management.azure.com/",
  "activeDirectoryGraphResourceId": "https://graph.windows.net/",
  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",
  "galleryEndpointUrl": "https://gallery.azure.com/",
  "managementEndpointUrl": "https://management.core.windows.net/"
}


# 서비스 주체 목록
$ az ad sp list -o table  | grep tiuaxcoerefacr-sp
The result is not complete. You can still use '--all' to get all of them with long latency expected, or provide a filter through command arguments
DisplayName               Id                                    AppId                                 CreatedDateTime
------------------------  ------------------------------------  ------------------------------------  --------------------
http://tiuaxcoetmpacr-sp  3d7217d2-56d0-4fb5-b401-cb562c5aee24  6f71cdcd-7f75-4522-98d5-95f0ebc5cce6  2024-08-17T02:54:48Z


```





### (2) GitHub Secrets/Variables 설정

이제 서비스 주체 정보를 GitHub Secrets에 추가하여 GitHub Actions에서 사용할 수 있도록 한다.

1. **GitHub 리포지토리로 이동**

   - 리포지토리의 메인 페이지로 이동한다.

2. **Settings 탭 클릭**

   - 상단 메뉴에서 `Settings` 탭을 클릭한다.

3. **Secrets 설정**

   - 왼쪽 사이드바에서 `Secrets`를 클릭하고, `New repository secret` 버튼을 클릭하여 새로운 시크릿을 추가한다.
   - 다음 시크릿을 추가한다
     - `AZURE_CLIENT_SECRET`: 서비스 주체 `password`
     - `AZURE_CREDENTIALS`: 전체 json

4. Variables 설정

   * 변수추가

     * `ACR_NAME`: ACR 이름

     - `AZURE_CLIENT_ID`: 서비스 주체 `appId`
     - `AZURE_TENANT_ID`: 서비스 주체 `tenant`
     - `AZURE_SUBSCRIPTION_ID`: Azure 구독 ID
     - `PERSONAL_ID`: 사번





# 3. Dockerfile

Maven을 사용하여 Java 애플리케이션을 빌드를 포함한 Docker File 생성

## 1) Dockerfile

```Dockerfile
# Stage 1: Build the application using Maven
FROM maven:3.8.5-openjdk-17-slim AS build

# Set the working directory inside the container
WORKDIR /app

# Copy the pom.xml and download the dependencies
COPY pom.xml ./
RUN mvn dependency:go-offline

# Copy the entire source code
COPY src ./src

# Package the application
RUN mvn clean package -DskipTests

# Stage 2: Create a smaller, final image
FROM openjdk:17-jdk-slim

# Set the working directory inside the container
WORKDIR /app

# Copy the JAR file from the build stage
COPY --from=build /app/target/healthcheck*.jar /app/healthcheck.jar

# Expose the application port
EXPOSE 8080

# Define the command to run the application
CMD ["java", "-jar", "/app/healthcheck.jar"]
```

## 2) 단계별 설명

1. **Stage 1: Build Stage**

   - **Base Image:** `maven:3.8.5-openjdk-17-slim` 이미지를 사용. 이 이미지는 Maven과 OpenJDK 17이 설치되어 있음

   - **Working Directory:** `/app` 디렉토리를 작업 디렉토리로 설정

   - **Dependency Caching:** `pom.xml` 파일을 먼저 복사하고 `mvn dependency:go-offline`을 실행하여 종속성을 캐시한다. 이를 통해 빌드 속도를 높이고, 소스 코드가 변경되지 않은 경우 종속성을 다시 다운로드하지 않음.

     프로젝트의 모든 의존성 및 플러그인을 미리 다운로드하여, 이후 **오프라인 환경**에서도 Maven 작업이 원활히 실행되도록 준비

   - **Build:** `mvn clean package -DskipTests` 명령어를 실행하여 테스트를 건너뛰고 애플리케이션을 빌드. 이 단계에서 `target/` 디렉토리에 JAR 파일이 생성

2. **Stage 2: Final Image**

   - **Base Image:** `openjdk:17-jdk-slim` 이미지를 사용. 이 이미지는 JDK만 포함된 경량 이미지
   - **Copy Artifacts:** 첫 번째 단계에서 생성된 JAR 파일을 최종 이미지의 `/app/` 디렉토리에 복사
   - **Expose Port:** 애플리케이션이 사용하는 포트(예: 8080)를 외부에 노출
   - **CMD:** `java -jar` 명령어를 사용하여 JAR 파일을 실행



## 3) 사용 방법

이 Dockerfile을 프로젝트 루트 디렉토리에 저장한 후, Docker 이미지를 빌드하고 실행

```bash
docker build -t healthcheck .
docker run -p 8080:8080 healthcheck
```

이제 Docker 컨테이너에서 Java 애플리케이션이 실행되며, 호스트 머신의 포트 8080에서 접근



## 4) 실습

생략...



# 4. 샘플 워크플로우

## 1) workflow

프로젝트 루트 디렉토리에 `.github/workflows` 디렉토리를 만들고, 그 안에 `sample-ci.yml` 파일을 생성한다.

```yaml
name: sample-ci


on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Run tests
        run: |
          docker run --rm myapp:${{ github.sha }} /bin/sh -c "echo Running tests && exit 0"

      - name: Upload Docker image to Docker Hub
        if: github.ref == 'refs/heads/main'
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main'
        run: |
          docker tag myapp:${{ github.sha }} myapp:latest
          docker push myapp:${{ github.sha }}
          docker push myapp:latest
```



## 2) 설명

1. **이벤트 트리거**:

   - `on: push`: main 브랜치에 푸시될 때 트리거된다.
   - `on: pull_request`: main 브랜치에 대한 풀 리퀘스트가 열리거나 업데이트될 때 트리거된다.

   

2. **작업 설정 (jobs)**:

   - `build`: 이 작업은 `ubuntu-latest` 환경에서 실행된다.

   

3. **단계 (steps)**:

   - **체크아웃 리포지토리**: `actions/checkout@v2` 액션을 사용하여 리포지토리를 체크아웃한다.
   - **Docker Buildx 설정**: `docker/setup-buildx-action@v1` 액션을 사용하여 Docker Buildx를 설정한다.
   - **Docker 레이어 캐시**: `actions/cache@v2` 액션을 사용하여 Docker 레이어를 캐시한다. 이는 빌드 속도를 향상시키는 데 도움이 된다.
   - **Docker 이미지 빌드**: `docker build` 명령어를 사용하여 Docker 이미지를 빌드한다.
   - **테스트 실행**: Docker 컨테이너에서 테스트를 실행한다. 여기서는 간단히 `echo` 명령어로 테스트를 대체한다.
   - **Docker Hub 로그인**: `docker/login-action@v1` 액션을 사용하여 Docker Hub에 로그인한다. Docker Hub 자격 증명은 GitHub Secrets에 저장되어 있어야 한다 (`DOCKER_USERNAME` 및 `DOCKER_PASSWORD`).
   - **Docker 이미지 푸시**: `docker push` 명령어를 사용하여 빌드된 이미지를 Docker Hub에 푸시한다.

   

## 3) GitHub Secrets 설정

1. **GitHub 리포지토리로 이동**:
   - 리포지토리의 메인 페이지로 이동한다.

2. **Settings 탭 클릭**:
   - 상단 메뉴에서 `Settings` 탭을 클릭한다.

3. **Secrets 설정**:
   - 왼쪽 사이드바에서 `Secrets`를 클릭하고, `New repository secret` 버튼을 클릭하여 새로운 시크릿을 추가한다.
   - `DOCKER_USERNAME`과 `DOCKER_PASSWORD` 시크릿을 추가한다.



## 4) 시크릿 예시

- `DOCKER_USERNAME`: Docker Hub 사용자 이름
- `DOCKER_PASSWORD`: Docker Hub 비밀번호 또는 접근 토큰

이 설정을 통해 GitHub Actions를 사용하여 Docker 컨테이너를 빌드하고, 테스트를 실행하며, Docker Hub에 이미지를 푸시하는 CI 파이프라인을 구성할 수 있다. 필요에 따라 단계나 설정을 조정하여 프로젝트에 맞게 최적화할 수 있다.



# 5. CI Pipeline Sample



```yaml
name: CI Pipeline

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Login to Azure CLI
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Log in to Azure Container Registry
        run: |
          echo ${{ secrets.AZURE_CLIENT_SECRET }} | docker login ${{ secrets.ACR_NAME }}.azurecr.io -u ${{ secrets.AZURE_CLIENT_ID }} --password-stdin
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/myapp:${{ github.sha }} .
      - name: Push Docker image to ACR
        run: |
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/myapp:${{ github.sha }}
      - name: Logout from Azure Container Registry
        run: |
          docker logout ${{ secrets.ACR_NAME }}.azurecr.io
          
```





# 6.  GitHub Actions Repo수정권한 부여

Action pipeline 수행시 TagVersion 을 수정하는등 Repo를 직접 수정해야 하는 상황이 있을 수 있다.  이때는 Read/Write 권한을 부여해야 한다.

그렇지 않으면 403에러가 발생한다.  해결방안은 아래와 같다.



## 1) **Repository Permission 설정 확인**

먼저, `GITHUB_TOKEN`이 올바른 권한을 가지고 있는지 확인해야 합니다. 리포지토리 설정에서 워크플로우가 푸시할 수 있는 권한을 가지고 있는지 확인해야 한다.

1. **리포지토리 설정에서 권한 확인:**
   - 리포지토리로 이동한 다음, "Settings" > "Actions" > "General"로 이동
   - "Workflow permissions" 섹션
   - "Read and write permissions" 옵션이 선택되어 있는지 확인
   - "Allow GitHub Actions to create and approve pull requests" 옵션도 필요에 따라 체크

이 설정을 통해 `GITHUB_TOKEN`이 리포지토리에 푸시할 수 있는 권한을 부여



## 2) **GitHub Actions YAML 파일에서 GITHUB_TOKEN 설정**

`GITHUB_TOKEN`이 이미 설정되어 있지만, 여전히 문제가 발생하는 경우에는 `git push` 명령어에서 사용하는 토큰 형식을 다음과 같이 수정

```yaml
- name: Commit and push updated kustomization.yaml
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  run: |
    git config --local user.email "github-actions[bot]@users.noreply.github.com"
    git config --local user.name "github-actions[bot]"
    git add $KUSTOMIZATION_FILE
    git commit -m "Update image tag to ${{ github.event.inputs.TagVersion }} in kustomization.yaml"
    git push https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git HEAD:${{ github.ref_name }}
```



## 3) **브랜치 보호 설정 확인**

보호된 브랜치의 경우, 푸시하려는 브랜치에 대해 브랜치 보호 규칙이 설정되어 있을 수 있다. 이 경우, GitHub Actions가 보호된 브랜치로 직접 푸시할 수 없도록 되어 있을 수 있다. 보호된 브랜치로 푸시를 허용하려면 다음과 같은 작업이 필요할 수 있다

**브랜치 보호 규칙에서 예외 추가:**

- 리포지토리에서 "Settings" > "Branches"로 이동
- "Branch protection rules" 섹션에서 보호된 브랜치를 선택
- "Require pull request reviews before merging"와 같은 옵션이 활성화되어 있는 경우, 이를 수정하거나 GitHub Actions의 푸시를 허용하도록 예외 규칙을 추가

**풀 리퀘스트 생성:**

- 보호된 브랜치에 직접 푸시가 허용되지 않는 경우, GitHub Actions에서 자동으로 Pull Request를 생성하게 하여 검토 후 머지하는 방식으로 처리할 수 있다.



## 4) **토큰 관련 오류 해결**

토큰이 제대로 전달되지 않아서 발생할 수 있는 문제도 있다. 만약 환경 변수 `GITHUB_TOKEN`이 제대로 설정되지 않았을 가능성이 있다면, 이를 명확히 지정

