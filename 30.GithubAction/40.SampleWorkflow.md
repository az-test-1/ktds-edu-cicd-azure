

# CI Workflow Sample



[[_TOC_]]



# 1. 개요

GitHub Actions Sample worklow를 살펴본다.





# 2. 기초

## 1) CI Sample1



```yaml
name: Deploy vm using ssh and blob 

on:
  workflow_dispatch:
    inputs:
      runner:
        required: true
        type: choice
        options:
          - arc-runner-axccoe-dev
          # - self-hosted
          - ubuntu-latest
      environment:
        description: "Deployment environment"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - prd

jobs:
  build:
    name: (${{ inputs.environment }}) Build using maven
    runs-on: "${{ inputs.runner }}"

    steps:
    # - name: Cache Maven packages
    #   uses: actions/cache@v4
    #   with:
    #     path: ~/.m2/repository
    #     key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
    #     restore-keys: |
    #       ${{ runner.os }}-maven-

    # - name: Set up jdk 17
    #   uses: actions/setup-java@v4
    #   with:
    #     java-version: '17'
    #     distribution: 'temurin'
    #     cache: maven
    
```



* workflow_dispatch
  * workflow_dispatch는 GitHub Actions에서 워크플로우를 **수동으로 트리거**할 수 있게 해주는 이벤트.
  * 즉, 코드가 푸시되거나 PR이 생성될 때처럼 자동으로 워크플로우가 실행되는 것이 아니라, 사용자가 GitHub 웹 UI 또는 API를 통해 직접 실행할 수 있는 기능을 제공한다.
  * workflow_dispatch에서는 입력 파라미터를 정의할 수 있으며 사용자는 워크플로우를 실행할 때 해당 파라미터를 제공하여 동적으로 실행 조건을 설정할 수 있습니다.
    * ex) TagVersion은 사용자로부터 받는 **입력값**으로, Docker 이미지 태그 버전을 지정하는 입력입니다.













# 3. VM 기반



## 1)  CI Sample1



## 2)  CI Sample2



### (1) workflow

```yaml
name: Deploy vm using ssh and blob 

on:
  workflow_dispatch:
    inputs:
      runner:
        required: true
        type: choice
        options:
          - arc-runner-axccoe-dev
          # - self-hosted
          - ubuntu-latest
      environment:
        description: "Deployment environment"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - prd

jobs:
  build:
    name: (${{ inputs.environment }}) Build using maven
    runs-on: "${{ inputs.runner }}"

    steps:
    # - name: Cache Maven packages
    #   uses: actions/cache@v4
    #   with:
    #     path: ~/.m2/repository
    #     key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
    #     restore-keys: |
    #       ${{ runner.os }}-maven-

    # - name: Set up jdk 17
    #   uses: actions/setup-java@v4
    #   with:
    #     java-version: '17'
    #     distribution: 'temurin'
    #     cache: maven
            
    - name: Check out the repo
      uses: actions/checkout@v4.1.7
      # uses: ./../../common/actions/checkout-v4.1.7
      with:
        fetch-depth: 1
        # path: ${{ github.event.repository.name }}-${{ github.ref_name }}

    - name: Configure maven settings.xml
      run: |
          cat <<EOF > ./settings.xml
          <settings>
          <servers>
              <server>
              <id>github</id>
              <username>${{ github.actor }}</username>
              <password>${{ secrets.GH_ADMIN_TOKEN }}</password>
              </server>
          </servers>
          </settings>
          EOF

    - name: Package artifact file
      run: mvn -B -DskipTests package --file ./pom.xml -s ./settings.xml

    - name: Log in to Azure CLI
      env:
        AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_COMMON }}
      run: |
        echo "$AZURE_CREDENTIALS" > azure_credentials.json
        az login \
          --service-principal \
          --username $(jq -r .clientId azure_credentials.json) \
          -p=$(jq -r .clientSecret azure_credentials.json) \
          --tenant $(jq -r .tenantId azure_credentials.json)
        az account set --subscription $(jq -r .subscriptionId azure_credentials.json)
      shell: bash

    - name: Upload jar file to Object Storage
      run: |
        az storage blob upload \
          --account-name ${{ vars.AZURE_COMMON_STORAGE_ACCOUNT }} \
          --container-name ${{ vars.AZURE_COMMON_ARTIFACT_CONTAINER }} \
          --file ./target/*.jar \
          --name ${{ vars.APP_NAME }}.jar \
          --overwrite \
          --auth-mode login
      shell: bash

  deploy-dev:
    name: (${{ inputs.environment }}) Deploy using ssh and blob
    runs-on: "${{ inputs.runner }}"
    needs: build
    if: ${{ inputs.environment == 'dev' }}
    steps:
      - name: Deploy java app
        uses: ./.github/workflows/actions/deploy-ssh-blob-vm
        with:
          environment: "${{ inputs.environment }}"
          storage-account: "${{ vars.AZURE_COMMON_STORAGE_ACCOUNT }}"
          storage-container: "${{ vars.AZURE_COMMON_ARTIFACT_CONTAINER }}"
          storage-access-key: "${{ secrets.AZURE_COMMON_STORAGE_ACCESS_KEY }}"
          ssh-private-key: "${{ secrets.AZURE_VM_SSH_PRIVATE_KEY_DEV }}"
          vm-prefix: "${{ vars.AZURE_VM_PREFIX }}"
          vm-suffix: "vm"
          vm-ip: "${{ secrets.AZURE_VM_IP_DEV }}"
          vm-user: "${{ vars.AZURE_VM_USER }}"
          app-name: "${{ vars.APP_NAME }}"

  deploy-prd:
    name: (${{ inputs.environment }}) Deploy using ssh and blob
    runs-on: "${{ inputs.runner }}"
    needs: build
    if: ${{ inputs.environment == 'prd' }}
    strategy:
      matrix:
        vm-ips: [prd1, prd2]
    steps:
      - name: Extract VM IP
        run: echo "TARGET_VM_IP=$(echo '${{ secrets.AZURE_VM_IP_PRD }}' | jq -r .${{ matrix.vm-ips }} )" >> $GITHUB_ENV

      - name: Deploy java app
        uses: ./.github/workflows/actions/deploy-ssh-blob-vm
        env:
          TARGET_VM_IP: ${{ env.TARGET_VM_IP }}
        with:
          environment: "${{ inputs.environment }}"
          storage-account: "${{ vars.AZURE_COMMON_STORAGE_ACCOUNT }}"
          storage-container: "${{ vars.AZURE_COMMON_ARTIFACT_CONTAINER }}"
          storage-access-key: "${{ secrets.AZURE_COMMON_STORAGE_ACCESS_KEY }}"
          ssh-private-key: "${{ secrets.AZURE_VM_SSH_PRIVATE_KEY_PRD }}"
          vm-prefix: "${{ vars.AZURE_VM_PREFIX }}"
          vm-suffix: "vm"
          vm-ip: "${{ env.TARGET_VM_IP }}"
          vm-user: "${{ vars.AZURE_VM_USER }}"
          app-name: "${{ vars.APP_NAME }}"
          
```

1. self-hosted runner , dev 선택
2. Maven 파일 빌드
3. blob storage에 Upload
4. Dev 환경의 VM 접속
5. Blob Storagre에서 download
6. Java Application 배포 스크립트 “deploy-jar.sh” 실행



### (2) customizing action.yml 

.github/workflows/actions/deploy-ssh-blob-vm/action.yml

```sh
name: Deploy Java App
description: Deploy Java Application to VM using ssh and blob
inputs:
  environment:
    required: true
    default: ""
  storage-account:
    required: true
    default: ""
  storage-container:
    required: true
    default: ""
  storage-access-key:
    required: true
    default: ""
  ssh-private-key:
    required: true
    default: ""
  vm-prefix:
    required: true
    default: ""
  vm-suffix:
    required: true
    default: ""
  vm-ip:
    required: true
    default: ""
  vm-user:
    required: true
    default: ""
  app-name:
    required: true
    default: ""

runs:
  using: "composite"
  steps:
    - name: Set up ssh private key
      run: |
        mkdir -p ~/.ssh/
        echo "${{ inputs.ssh-private-key }}" > ~/.ssh/${{ inputs.vm-prefix }}-${{ inputs.environment }}-${{ inputs.vm-suffix }}.pem
        chmod 600 ~/.ssh/${{ inputs.vm-prefix }}-${{ inputs.environment }}-${{ inputs.vm-suffix }}.pem
      shell: bash

    - name: Run java application
      run: |  
        ssh -i ~/.ssh/${{ inputs.vm-prefix }}-${{ inputs.environment }}-${{ inputs.vm-suffix }}.pem -o StrictHostKeyChecking=no ${{ inputs.vm-user }}@${{ inputs.vm-ip }} << 'EOF'
          set -e
          az storage blob download \
            --account-name ${{ inputs.storage-account }} \
            --container-name ${{ inputs.storage-container }} \
            --file ./deploy-jar.sh --name deploy-jar.sh --auth-mode key --account-key ${{ inputs.storage-access-key }}
          chmod 755 ./deploy-jar.sh
          ./deploy-jar.sh ${{ inputs.app-name }} ${{ inputs.vm-user }} ${{ inputs.environment }} ${{ inputs.storage-account }} ${{ inputs.storage-container }} ${{ inputs.storage-access-key }}
        EOF
      shell: bash

```







### (3) deploy-jar.sh 구성

```sh
#!/bin/bash

# Usage: ./deploy.sh <app_name> <username> <profile>
# Example: ./deploy.sh mvp-springboot-jdk17 azureadmin dev

set -e

# Parameters
APP_NAME=$1
USERNAME=$2
PROFILE=$3
STORAGE_ACCOUNT=$4
STORAGE_CONTAINER=$5
STORAGE_ACCESS_KEY=$6

# Validate parameters
if [ -z "$APP_NAME" ] || [ -z "$USERNAME" ] || [ -z "$PROFILE" ]; then
  echo "Error: Missing required parameters."
  echo "Usage: $0 <app_name> <username> <profile>"
  exit 1
fi

# Log file
LOG_FILE="/home/${USERNAME}/${APP_NAME}.log"

echo "Starting download process for application: ${APP_NAME}"
az storage blob download \
  --account-name tiurefcomsa \
  --container-name tiu-ref-com-arti-con \
  --file ./${APP_NAME}.jar --name ${APP_NAME}.jar \
  --auth-mode key --account-key ${STORAGE_ACCESS_KEY}
echo "Download completed. Artifact filename is ${APP_NAME}.jar..."

echo "Starting deployment process for application: ${APP_NAME}"
echo "Using user: ${USERNAME}"
echo "Spring profile: ${PROFILE}"

# Kill any existing process running with the JAR name
echo "Attempting to stop any running instances of ${APP_NAME}.jar..."
sudo pkill -f "${APP_NAME}.jar" || true
echo "Process termination completed."

# Start the new process
echo "Starting the new instance of ${APP_NAME}.jar with profile ${PROFILE}..."
nohup java -jar /home/${USERNAME}/${APP_NAME}.jar \
    --spring.profiles.active=${PROFILE} >> ${LOG_FILE} 2>&1 &
echo "New process started. Logs are being written to ${LOG_FILE}."

echo "Deployment completed successfully."
4. Github Actions 실행

```









# 4. Container 기반



## 1) CI Sample1



```yaml
name: CI Pipeline

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Login to Azure CLI
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Log in to Azure Container Registry
        run: |
          echo ${{ secrets.AZURE_CLIENT_SECRET }} | docker login ${{ secrets.ACR_NAME }}.azurecr.io -u ${{ secrets.AZURE_CLIENT_ID }} --password-stdin
          
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/myapp:${{ github.sha }} .
          
      - name: Push Docker image to ACR
        run: |
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/myapp:${{ github.sha }}
          
      - name: Logout from Azure Container Registry
        run: |
          docker logout ${{ secrets.ACR_NAME }}.azurecr.io
          
```





## 2) CI Sample2

### (1) workflow

프로젝트 루트 디렉토리에 `.github/workflows` 디렉토리를 만들고, 그 안에 `sample-ci.yml` 파일을 생성한다.

```yaml
name: sample-ci


on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      name:
        # Friendly description to be shown in the UI instead of 'name'
        description: 'Person to greet'
        # Default value if no value is explicitly provided
        default: 'World'
        # Input has to be provided for the workflow to run
        required: true
        # The data type of the input
        type: string

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Cache Docker layers
        uses: actions/cache@v2
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build Docker image
        run: |
          docker build -t myapp:${{ github.sha }} .

      - name: Run tests
        run: |
          docker run --rm myapp:${{ github.sha }} /bin/sh -c "echo Running tests && exit 0"

      - name: Upload Docker image to Docker Hub
        if: github.ref == 'refs/heads/main'
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push Docker image
        if: github.ref == 'refs/heads/main'
        run: |
          docker tag myapp:${{ github.sha }} myapp:latest
          docker push myapp:${{ github.sha }}
          docker push myapp:latest
```



### (2) 설명

1. **이벤트 트리거**:

   - `on: push`: main 브랜치에 푸시될 때 트리거된다.
   - `on: pull_request`: main 브랜치에 대한 풀 리퀘스트가 열리거나 업데이트될 때 트리거된다.

   

2. **작업 설정 (jobs)**:

   - `build`: 이 작업은 `ubuntu-latest` 환경에서 실행된다.

   

3. **단계 (steps)**:

   - **체크아웃 리포지토리**: `actions/checkout@v2` 액션을 사용하여 리포지토리를 체크아웃한다.
   - **Docker Buildx 설정**: `docker/setup-buildx-action@v1` 액션을 사용하여 Docker Buildx를 설정한다.
   - **Docker 레이어 캐시**: `actions/cache@v2` 액션을 사용하여 Docker 레이어를 캐시한다. 이는 빌드 속도를 향상시키는 데 도움이 된다.
   - **Docker 이미지 빌드**: `docker build` 명령어를 사용하여 Docker 이미지를 빌드한다.
   - **테스트 실행**: Docker 컨테이너에서 테스트를 실행한다. 여기서는 간단히 `echo` 명령어로 테스트를 대체한다.
   - **Docker Hub 로그인**: `docker/login-action@v1` 액션을 사용하여 Docker Hub에 로그인한다. Docker Hub 자격 증명은 GitHub Secrets에 저장되어 있어야 한다 (`DOCKER_USERNAME` 및 `DOCKER_PASSWORD`).
   - **Docker 이미지 푸시**: `docker push` 명령어를 사용하여 빌드된 이미지를 Docker Hub에 푸시한다.

   

### (3) GitHub Secrets 설정

1. **GitHub 리포지토리로 이동**:
   - 리포지토리의 메인 페이지로 이동한다.

2. **Settings 탭 클릭**:
   - 상단 메뉴에서 `Settings` 탭을 클릭한다.

3. **Secrets 설정**:
   - 왼쪽 사이드바에서 `Secrets`를 클릭하고, `New repository secret` 버튼을 클릭하여 새로운 시크릿을 추가한다.
   - `DOCKER_USERNAME`과 `DOCKER_PASSWORD` 시크릿을 추가한다.



### (4) 시크릿 예시

- `DOCKER_USERNAME`: Docker Hub 사용자 이름
- `DOCKER_PASSWORD`: Docker Hub 비밀번호 또는 접근 토큰

이 설정을 통해 GitHub Actions를 사용하여 Docker 컨테이너를 빌드하고, 테스트를 실행하며, Docker Hub에 이미지를 푸시하는 CI 파이프라인을 구성할 수 있다. 필요에 따라 단계나 설정을 조정하여 프로젝트에 맞게 최적화할 수 있다.







## 3) CI Sample3

Github Action에서 기본적으로 제공하는 Sample workflow이다.



### (1) workflow

```sh
name: Docker

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

on:
  schedule:
    - cron: '34 8 * * *'
  push:
    branches: [ "main" ]
    # Publish semver tags as releases.
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ "main" ]

env:
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io
  # github.repository as <account>/<repo>
  IMAGE_NAME: ${{ github.repository }}


jobs:
  build:

    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install the cosign tool except on PR
      # https://github.com/sigstore/cosign-installer
      - name: Install cosign
        if: github.event_name != 'pull_request'
        uses: sigstore/cosign-installer@59acb6260d9c0ba8f4a2f9d9b48431a222b68e20 #v3.5.0
        with:
          cosign-release: 'v2.2.4'

      # Set up BuildKit Docker container builder to be able to build
      # multi-platform images and export cache
      # https://github.com/docker/setup-buildx-action
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@f95db51fddba0c2d1ec667646a06c2ce06100226 # v3.0.0

      # Login against a Docker registry except on PR
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        if: github.event_name != 'pull_request'
        uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels) for Docker
      # https://github.com/docker/metadata-action
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@96383f45573cb7f253c731d3b3ab81c87ef81934 # v5.0.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      # Build and push Docker image with Buildx (don't push on PR)
      # https://github.com/docker/build-push-action
      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@0565240e2d4ab88bba5387d719585280857ece09 # v5.0.0
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Sign the resulting Docker image digest except on PRs.
      # This will only write to the public Rekor transparency log when the Docker
      # repository is public to avoid leaking data.  If you would like to publish
      # transparency data even for private images, pass --force to cosign below.
      # https://github.com/sigstore/cosign
      - name: Sign the published Docker image
        if: ${{ github.event_name != 'pull_request' }}
        env:
          # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
          TAGS: ${{ steps.meta.outputs.tags }}
          DIGEST: ${{ steps.build-and-push.outputs.digest }}
        # This step uses the identity token to provision an ephemeral certificate
        # against the sigstore community Fulcio instance.
        run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}

```



이 GitHub Actions 워크플로우는 **Docker 이미지**를 빌드하고 **레지스트리에 푸시**한 다음, 이미지를 **서명(sign)**하는 과정을 자동화하는 파이프라인입니다. 주요 기능은 **코드 푸시**, **PR 생성**, 또는 **스케줄**에 맞춰 Docker 이미지를 관리하는 것입니다. 각 단계의 기능을 간단히 설명하겠습니다.



### 1. **Workflow 트리거 (on: section)**

- **schedule**: `cron` 형식으로 정의된 스케줄(매일 03:17)에 워크플로우가 실행됩니다.
- **push**: `main` 브랜치에 푸시되거나 `v*.*.*` 태그 형식의 태그가 달린 커밋이 푸시될 때 트리거됩니다.
- **pull_request**: `main` 브랜치에 대한 PR(pull request) 생성 시 워크플로우가 실행됩니다.

### 2. **환경 변수 설정 (env: section)**

- **REGISTRY**: `ghcr.io`가 기본값이며, Docker 이미지를 푸시할 컨테이너 레지스트리입니다. 설정하지 않으면 Docker Hub를 기본으로 사용합니다.
- **IMAGE_NAME**: GitHub 리포지토리 이름을 Docker 이미지 이름으로 사용합니다.

### 3. **Job: build**

- **runs-on**: 이 워크플로우는 `ubuntu-latest` 환경에서 실행됩니다.
- **permissions**: GitHub Actions에 필요한 권한을 설정합니다.
  - `id-token`: 이미지 서명에 사용되는 토큰 발급에 필요한 권한입니다.

### 4. **Checkout repository**

- **Checkout repository**: `actions/checkout@v4`를 사용하여 리포지토리 코드를 현재 작업 디렉토리로 체크아웃합니다.

### 5. **Install cosign (cosign 설치)**

- PR을 제외한 상황에서 `sigstore/cosign`이라는 서명 도구를 설치합니다. 이 도구는 Docker 이미지를 서명하는 데 사용됩니다.

### 6. **Set up Docker Buildx**

- **Buildx 설치**: 멀티 플랫폼 이미지를 빌드할 수 있는 Docker Buildx 환경을 설정합니다. 이는 여러 CPU 아키텍처에 대한 이미지를 생성하는 데 유용합니다.

### 7. **Log into registry**

- PR을 제외한 상황에서 레지스트리(기본적으로 `ghcr.io` 또는 지정된 레지스트리)에 로그인합니다. 레지스트리에 로그인하여 Docker 이미지를 푸시할 수 있도록 설정합니다.

### 8. **Extract Docker metadata**

- Docker 이미지의 메타데이터(예: 태그 및 레이블)를 추출합니다. `docker/metadata-action`을 사용하여 빌드할 이미지의 태그 및 레이블을 정의합니다.

### 9. **Build and push Docker image**

- **Docker 이미지 빌드 및 푸시**: Docker 이미지를 빌드하고, PR이 아닌 경우 자동으로 레지스트리에 푸시합니다.
  - `push`: PR이 아닐 때에만 이미지를 레지스트리에 푸시.
  - **Cache**: `gha` 캐시를 사용하여 빌드 시간을 최적화합니다.

### 10. **Sign the published Docker image**

- PR이 아닐 때에 빌드된 Docker 이미지에 서명합니다. 이 과정은 이미지에 대한 신뢰성을 보장하는 역할을 합니다. `cosign`을 사용하여 서명하며, 서명된 데이터를 공개 **Rekor 투명성 로그**에 기록합니다.





## 4) CI Sample4



```yaml
name: CI Pipeline

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  workflow_dispatch:
    # Inputs the workflow accepts.
    inputs:
      TagVersion:
        description: 'Tag version for Docker image'
        required: true
        default: 'v1.0.0'
        type: string
      ChoiceVersion:
        description: 'Select a Tag Version'
        required: true
        type: choice
        options:
          - v1.0.0
          - v1.0.1
          - v1.0.2

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    runs-on: ubuntu-latest
    
    env:
      IMAGE_NAME: ${{ vars.ACR_NAME }}.azurecr.io/${{ vars.PERSONAL_ID }}/healthcheck:${{ github.event.inputs.TagVersion }}
      IMAGE_NAME_LATEST: ${{ vars.ACR_NAME }}.azurecr.io/${{ vars.PERSONAL_ID }}/healthcheck:latest
      KUSTOMIZATION_FILE: gitops/kustomization.yaml
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Login to Azure CLI
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Log in to Azure Container Registry
        run: |
          echo ${{ secrets.AZURE_CLIENT_SECRET }} | docker login ${{ vars.ACR_NAME }}.azurecr.io -u ${{ vars.AZURE_CLIENT_ID }} --password-stdin

      - name: 현재 디렉토리 확인
        run: |
          pwd
          ls -ltr
    
      - name: Build Docker image
        run: |
          echo "IMAGE_NAME: "$IMAGE_NAME
          docker build -t $IMAGE_NAME .

      - name: Tag image as latest
        run: |
          docker tag $IMAGE_NAME $IMAGE_NAME_LATEST

      - name: Push Docker image to ACR
        run: |
          docker push $IMAGE_NAME

      - name: Push Docker image as latest
        run: |
          docker push $IMAGE_NAME_LATEST          

      - name: Update kustomization.yaml with newTag
        run: |
          sed -i "s/newTag: .*/newTag: ${{ github.event.inputs.TagVersion }}/" $KUSTOMIZATION_FILE

      - name: Commit and push updated kustomization.yaml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add $KUSTOMIZATION_FILE
          git commit -m "Update image tag to ${{ github.event.inputs.TagVersion }} in kustomization.yaml"
          git push https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git HEAD:${{ github.ref_name }}

      - name: Logout from Azure Container Registry
        run: |
          docker logout ${{ vars.ACR_NAME }}.azurecr.io

```





## 5) CI Sample5

Buildx 적용





